package com.operations;

import java.io.FileOutputStream;
import java.io.IOException;
import java.nio.charset.Charset;
import java.nio.file.Files;
import java.nio.file.Paths;

import javax.swing.JOptionPane;

/**
 * FileWorker is a class which reads all Bytes from a Bitmap and 
 * can hide a Message within said Bitmap by changing the Least Significant
 * Bit inside of the value of each RGB color of a pixxel. To be gained a bit
 * security not every next Byte is changed, but a few are overjumped with a
 * gained keySet which is generated by a user defined password.
 * @author Floeke
 *
 */
public class FileWorker {
	
	private byte[] data;
	private FileOutputStream fos;
	private int[] keySet;
	private String filename;
	
	/**
	 * Constructor of the FileReader
	 * @param filename Name of the File to read (Path)
	 */
	public FileWorker(String filename)
	{
		this.filename = filename;
		try {
			data = Files.readAllBytes(Paths.get(filename));			
		} catch (IOException e)
		{
			new JOptionPane("Unknown Filepath!").setVisible(true);
		}
	}
	
	/**
	 * Writes the message into the file
	 * @param message The message that wants to be crypted
	 * @param password Password to get keySet
	 * @throws IOException File not available
	 */
	public void toFile(String message, String password)
	{
		setKeySet(password);
		int currentByte = 60;
		int keyPos = 0;
		byte []messageBytes = message.getBytes(Charset.forName("UTF-8"));			
		int messageLength = messageBytes.length; 
		
		//Save the length of the message
		for(int i=31; i>=0; i--)
		{
			int x = (messageLength >>> i) & 0x01;
			if(keyPos > keySet.length-1) keyPos = 0;
			currentByte += (keySet[keyPos]+1);
			data[currentByte] = (byte)((data[currentByte] & (0xFE) | x));
			keyPos++;
		}
		
		//Save the message
		for(int i=0; i < messageLength; i++)
		{
			int zeichen = messageBytes[i]; //Current char of the message 
			for(int bit=7; bit>=0;--bit, ++keyPos)
			{
				int x = (zeichen >>> bit) & 0x01; //x saves the bit
				if(keyPos > keySet.length-1) keyPos = 0; //check keySet
				currentByte += (keySet[keyPos]+1);
				data[currentByte] = (byte)((data[currentByte] & (0xFE) | x)); //Write
				keyPos++;
			}
		}
		
		try {
			//Magic, do not touch!
			StringBuilder fileout = new StringBuilder();
			fileout.append(filename);
			fileout.insert(filename.length()-4, "Crypted");
			fos = new FileOutputStream(fileout.toString());
			fos.write(data);
		} catch (IOException e)
		{
			e.printStackTrace();
		}
		finally{
			try {
				fos.close();
			} catch (IOException e) 
			{
				e.printStackTrace();
			}
		}
		
	}
	
	/**
	 * Gets the message out of the current FileData
	 * @param password Password to get keySet
	 * @return String of the message
	 */
	public String getMessage(String password)
	{
		setKeySet(password);
		int currentByte = 60;
		int keyPos = 0;
		int messageLenght = 0;
		
		//Read the messagelength
		for(int i=31; i>= 0; i--)
		{
			if(keyPos > keySet.length-1) keyPos = 0;
			currentByte+=(keySet[keyPos]+1);
			messageLenght |= ((data[currentByte] & 0x01) << i);
			keyPos++;
		}
		
		//Catch negatives
		if(messageLenght < 0) 
			messageLenght = -messageLenght;
		
		byte []message = new byte[messageLenght];
		
		//Read the message
		for(int i=0; i < messageLenght; i++)
		{
			message[i] = 0;
			for(int bit = 7; bit >=0; bit--, keyPos++)
			{				
				if(keyPos > keySet.length-1) keyPos = 0;				
				currentByte += (keySet[keyPos]+1);
				message[i] |= ((data[currentByte] & 0x01) << bit);
				keyPos++;
			}			
		}
				
		return new String(message, Charset.forName("UTF-8"));
	}
	
	private void setKeySet(String password)
	{
		char a[] = password.toCharArray();
		keySet = new int[]{hash1(a), hash2(a), hash3(a)};
	}
	
	private static int hash1(char a[])
	{
		int hash=0;
		int length = a.length;
		for(int i=0; i<length; i++)
		{
			hash^=a[i];
			hash+=a[i];
			hash*=a[i];
			hash |= a[i] << (i-23);
		}
		
		if(hash > 0)
			return hash%8;
		return -(hash%8);
	}
	
	private static int hash2(char a[])
	{
		int hash=0;
		int length = a.length;
		for(int i=0; i<length; i++)
		{
			hash*=a[i];
			hash+=a[i];
			hash-=237;
			hash^=a[i];
		}
		
		if(hash > 0)
			return hash%8;
		return -(hash%8);
	}
	
	private static int hash3(char a[])
	{
		int hash=0;
		int length = a.length;
		for(int i=0; i<length; i++)
		{
			hash|=a[i];
			hash+=a[i];
			hash^=a[i];
			hash*=a[i];
		}
		
		if(hash > 0)
			return hash%8;
		return -(hash%8);
	}
}
